## ワークフロー A: Explore → Plan → Code → Commit

### Step 1: Explore
- 関連ファイル、画像、URLを読み込んで分析して。まだコードは書かないで。
- 実行内容：
  - 明示的なファイル参照または一般的な指示を使用
  - 複雑な問題の場合はサブエージェントで詳細を検証
- 完了条件：問題の全体像と要件を理解できた

### Step 2: Plan
- "think harder"モードで具体的なアプローチ計画を立てて。
- 実行内容：
  - 思考モード選択："think" < "think hard" < "think harder" < "ultrathink"
  - 計画をドキュメントまたはGitHub Issueに記録
  - 実装が計画と異なる場合の計画段階への復帰を可能にする
- 計画に含める項目：
  - 実装すべき機能の優先順位
  - 使用する技術・ライブラリ
  - ファイル構成
  - 実装手順
- 完了条件：詳細で実行可能な計画が作成されること

### Step 3: Code
- 計画に基づいて解決策を実装して。
- 実行内容：
  - Step 2で作成した計画に従って実装
  - 実装中に解決策の妥当性を検証
  - 必要に応じてサブエージェントで確認
- 完了条件：計画通りに動作するコードが完成した

### Step 4: Commit
- 結果をコミットしてPRを作成して。
- 実行内容：
  - 適切なコミットメッセージでコミット
  - プルリクエストを作成
  - 関連する場合はREADMEやchangelogを更新
- 完了条件：変更が適切にバージョン管理された

**重要：Step 1-2は解決策の品質向上に不可欠。早期のコーディングを防ぐ。**

---

## ワークフロー B: テスト作成 → コミット → コード → 反復 → コミット

### Step 1: テスト作成
- TDDアプローチでテストファーストで進める。
- 実行内容：
  - 期待する入出力に基づいてテストを生成
  - TDDと明示し、未実装部分でモック生成を避ける
- 完了条件：期待動作を検証するテストが作成された

### Step 2: テスト実行・コミット
- テストを実行して失敗確認後、コミットして。
- 実行内容：
  - テスト実行し失敗を確認
  - 実装はまだ書かない
  - テストをコミット
- 完了条件：失敗するテストがコミットされた

### Step 3: コード実装
- テストを通すコードを書いて。

- 実行内容：
  - テストを通すための最小限のコードを実装
  - テスト変更は禁止
  - 数回の反復でテスト合格を目指す
- 完了条件：すべてのテストが通過すること

### Step 4: 検証・コミット
- 実装の妥当性を確認してコミットして。
- 実行内容：
  - 実装がテストに過適合していないかサブエージェント検証
  - 問題なければコードをコミット
- 完了条件：適切に検証されたコードがコミットされること

---

## ワークフロー C: コード → スクリーンショット → 反復

### Step 1: 環境準備

- ブラウザスクリーンショット手段を用意して。
- 実行内容：
  - Playwright MCPなどのスクリーンショット機能を準備
- 完了条件：スクリーンショット撮影環境が整った

### Step 2: 初期実装
- デザインモックに合わせて初期実装して。
- 実行内容：
  - 提供されたデザインモック画像を参照
  - モックに合わせた初期実装
- 完了条件：基本的な実装が完了した

### Step 3: 反復改善
- スクショ撮影→比較→修正を反復して。
- 実行内容：
  - 実装後にスクリーンショットを撮影
  - モックと比較して差異を特定
  - 差異があれば修正して再度スクリーンショット
  - モックに十分近づくまで反復
- 完了条件：デザインモックとの差異が許容範囲内であるとユーザーが判断すること

### Step 4: 最終コミット
- ユーザーが満足できるレベルに達したらコミットして。
- 実行内容：
  - 最終的な実装をコミット
- 完了条件：UI実装が完了してコミットされること

---

## 使用ガイドライン

- **問題の性質に応じてワークフローを選択**
- **各ステップの完了条件を満たしてから次へ進む**
- **エラー時は前のステップに戻って再実行**
- **思考の深さ調整：think < think hard < think harder < ultrathink**
